# Sorting-algorithms-execution-time-comparison

//Сравнение времени выполнения алгоритмов сортировок на примере сортировки последователности из 100,000 
целых чисел.

Enter array size: 100000
Generation an array...done

-------Bubble sort-------
Amount of elements: 100000
Elasped time: 293.718188 sec
-------------------------

------Insertional sort------
Amount of elements: 100000
Elasped time: 258.721156 sec
----------------------------

------Selectional sort------
Amount of elements: 100000
Elasped time: 11.056420 sec
----------------------------

-------Merge sort---------
Amount of elements: 100000
Elasped time: 0.058278 sec
--------------------------

-------Pyramid sort-------
Amount of elements: 100000
Elasped time: 0.183829 sec
---------------------------

-------Quick sort---------
Amount of elements: 100000
Elasped time: 0.060005 sec

---------------------------

Для начала, вспомним показатели эффективности заданных алгоритмов:

Bubble sort -      O(n^2)
Insertional sort - O(n^2)
Selectional sort - O(n^2)
Merge sort -       O(n*log(n))
Pyramid sort -     O(n*log(n))
Quick sort -       O(n*log(n))


Приводить математику не имеет смысла. Это всё есть в википедии и на др. ресурсах.

Свои наблюдения:

Несмотря на схожие показатели эффективности у первых трёх алгоритмов, у Selectional sort показатель времени сортировки меньше в среднем
в 25 раз, поскольку, в нем максимальное количество операций обмена сведено к n-1 раз. При умеренной длине последовательности и 
отсутствии повышенных требований к скорости выполнения алгоритм Selectional sort неплохой выбор исходя из простоты её написания. Алгоритмы Quick sort и Merge sort выдают практически одинаковое время сортировки, но на более длинных последовательностях при применении Quick sort можно легко получить переполнения стека. Данная проблема отсутствует при применении Merge sort, однако, и она имеет недостаток: при выполнении процедуры слияния требуется дополнительная память для слияния двух отсортированных подпоследовательностей в одну. Подобная проблема отсутствует при выполнении Pyramid sort, однако этот алгоритм немного проигрывает по времени. В целом, для решения простых задач, умеренной длине последовательности, и когда нет необходимости в использовании более сложных алгоритмов Quick sort - хороший выбор, поскольку, он относительно прост в  написании при достаточно неплохих показателях эффективности.
